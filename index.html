<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Flappy Drone</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #70c5ce; /* sky blue */
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #70c5ce;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
(function() {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  const droneImg = new Image();
  droneImg.src = 'assets/images/sprite-drone.png';
  const SPRITE_SIZE = 1024; // dimensions of the sprite image
  const PADDING_TOP = 250;  // transparent padding inside the sprite
  const PADDING_LEFT = 125;

  const GRAVITY = 0.5;
  const JUMP = -8; // reduced jump power
  const GAP = 140; // vertical gap between obstacles
  const PIPE_WIDTH = 60;
  const PIPE_INTERVAL = 1600; // ms

  let lastPipeTime = 0;
  let pipes = [];
  let drone = { x: canvas.width * 0.25, y: canvas.height/2, vy: 0, width: 80, height: 64 };
  function getHitbox() {
    const scaleX = drone.width / SPRITE_SIZE;
    const scaleY = drone.height / SPRITE_SIZE;
    const padX = PADDING_LEFT * scaleX;
    const padY = PADDING_TOP * scaleY;
    return {
      x: drone.x + padX,
      y: drone.y + padY,
      width: drone.width - padX,
      height: drone.height - padY
    };
  }
  let score = 0;
  let running = false;

  // ----- Chiptune soundtrack using Web Audio API -----
  let audioCtx = null;
  const melody = [
    261.63, 293.66, 329.63, 349.23,
    392.0, 440.0, 493.88, 523.25
  ];

  function createNote(freq, time, duration) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, time);
    gain.gain.setValueAtTime(0.2, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + duration);
  }

  function createKick(time) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(0.001, time + 0.5);
    gain.gain.setValueAtTime(1, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + 0.5);
  }

  function createSnare(time) {
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(1, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
    noise.connect(gain).connect(audioCtx.destination);
    noise.start(time);
    noise.stop(time + 0.2);
  }

  function startSoundtrack() {
    if (audioCtx) {
      audioCtx.close();
    }
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const startT = audioCtx.currentTime + 0.1;
    const noteLen = 0.3;
    for (let i = 0; i < 64; i++) {
      const freq = melody[i % melody.length];
      const t = startT + i * noteLen;
      createNote(freq, t, noteLen);
      if (i % 4 === 0) createKick(t);
      if (i % 4 === 2) createSnare(t);
    }
  }

  function stopSoundtrack() {
    if (audioCtx) {
      audioCtx.close();
      audioCtx = null;
    }
  }

  function start() {
    pipes = [];
    drone.y = canvas.height/2;
    drone.vy = 0;
    lastPipeTime = performance.now();
    score = 0;
    startSoundtrack();
    running = true;
    window.requestAnimationFrame(loop);
  }

  function drawGameOver() {
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.font = 'bold 32px sans-serif';
    ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 20);
    ctx.font = 'bold 24px sans-serif';
    ctx.fillText('Tap to Restart', canvas.width/2, canvas.height/2 + 20);
  }

  function reset() {
    running = false;
    stopSoundtrack();
  }

  canvas.addEventListener('touchstart', () => {
    if (!running) { start(); return; }
    drone.vy = JUMP;
  });

  function addPipe() {
    const topHeight = 50 + Math.random() * (canvas.height - GAP - 100);
    pipes.push({ x: canvas.width, top: topHeight });
  }

  function update(delta) {
    if (performance.now() - lastPipeTime > PIPE_INTERVAL) {
      addPipe();
      lastPipeTime = performance.now();
    }
    drone.vy += GRAVITY;
    drone.y += drone.vy;

    const hitbox = getHitbox();
    if (hitbox.y + hitbox.height > canvas.height || hitbox.y < 0) {
      reset();
      return;
    }

    for (let i = pipes.length - 1; i >= 0; i--) {
      const p = pipes[i];
      p.x -= delta * 0.2; // pipe speed
      // collision
      if (p.x < hitbox.x + hitbox.width && p.x + PIPE_WIDTH > hitbox.x) {
        if (hitbox.y < p.top || hitbox.y + hitbox.height > p.top + GAP) {
          reset();
          return;
        }
      }
      if (p.x + PIPE_WIDTH < 0) {
        pipes.splice(i, 1);
        score++;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw drone
    if (droneImg.complete) {
      ctx.drawImage(droneImg, drone.x, drone.y, drone.width, drone.height);
    }
    // Draw pipes
    ctx.fillStyle = '#3a5f0b';
    pipes.forEach(p => {
      ctx.fillRect(p.x, 0, PIPE_WIDTH, p.top);
      ctx.fillRect(p.x, p.top + GAP, PIPE_WIDTH, canvas.height - p.top - GAP);
    });
    // Score
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(score, 10, 30);
  }

  let last = performance.now();
  function loop(now) {
    const delta = now - last;
    last = now;
    update(delta);
    draw();
    if (!running) {
      drawGameOver();
      return;
    }
    window.requestAnimationFrame(loop);
  }

  // Initial splash
  ctx.fillStyle = '#000';
  ctx.font = 'bold 24px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Tap to Start', canvas.width/2, canvas.height/2);
})();
</script>
</body>
</html>
